using System;
using System.ServiceModel;
using System.Threading.Tasks;
using System.ServiceModel.Channels;
using System.Reflection;

namespace DotNet462WcfAsyncFlowBug.Host
{
	[ServiceContract]
	interface IServiceA
	{
		[OperationContract]
		Task<string> Foo();
	}

	class ServiceA : IServiceA
	{
		public async Task<string> Foo()
		{
			var client = new Client.ServiceBClient();
			var result1 = await ServiceCallWithHeader(client, "1");
			var result2 = await ServiceCallWithHeader(client, "2");
			return $"{result1} and {result2}";
		}

		private async Task<string> ServiceCallWithHeader(Client.ServiceBClient client, string headerValue)
		{
			// We can avoid this issue by disabling the new async flow logic in .Net Framework 4.6.2 via an
			// internal static method.
			//
			//typeof(OperationContext)
			//	.GetMethod("DisableAsyncFlow", BindingFlags.Static | BindingFlags.NonPublic)
			//	.Invoke(null, null);

			try
			{
				// Pattern for the code below directed by the MSDN article for the OperationContextScope:
				// https://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontextscope(v=vs.110).aspx

				Task<string> task = null;
				using (new OperationContextScope(client.InnerChannel))
				{
					AddAuthorizationHeader(headerValue);
					task = client.BarAsync();
				}
				return await task;

				// The first implicit call to OperationContextScope's Dispose method will leave the scope 'stack' 
				// in a bad state. The second call will throw the exception we catch below.
			}
			catch (InvalidOperationException e)
			{
				// Place breakpoint here to inspect the exception generated by the second call to
				// OperationContextScope's Dispose method.

				throw;
			}
		}

		private static void AddAuthorizationHeader(string headerValue)
		{
			var header = MessageHeader.CreateHeader("Authorization", String.Empty, headerValue);
			OperationContext.Current.OutgoingMessageHeaders.Add(header);
		}
	}

	class ServiceAHost : IDisposable
	{
		private ServiceHost host;
		private bool disposed;

		public ServiceAHost()
		{
			InitializeServiceHost();
			SetEndpoint();
			host.Open();
		}

		private void InitializeServiceHost()
		{
			var serviceType = typeof(ServiceA);
			host = new ServiceHost(serviceType, Addresses.ServiceAUri);
		}

		private void SetEndpoint()
		{
			host.AddServiceEndpoint(typeof(IServiceA), new WSHttpBinding(), String.Empty);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
				return;

			if (disposing)
			{
				host.Close();
				((IDisposable)host).Dispose();
			}

			disposed = true;
		}
	}
}
